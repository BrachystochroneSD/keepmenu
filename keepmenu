#!/usr/bin/env python
# encoding:utf8
"""Read and copy Keepass database entries using dmenu or rofi

Add dmenu formatting options and default terminal if desired to
~/.config/keepmenu/config.ini

"""
import itertools
import locale
import os
from os.path import expanduser
import shlex
import sys
from subprocess import Popen, PIPE
from pykeepass import PyKeePass
from pykeyboard import PyKeyboard

try:
    import configparser as configparser
except ImportError:
    import ConfigParser as configparser

ENV = os.environ.copy()
ENV['LC_ALL'] = 'C'
ENC = locale.getpreferredencoding()
CONF = "~/.config/keepmenu/config.ini"

if sys.version_info.major < 3:
    str = unicode

def dmenu_cmd(num_lines, prompt="Entries"):  # pylint: disable=too-many-branches
    """Parse config.ini for dmenu options

    Args: args - num_lines: number of lines to display
                 promp: prompt to show
    Returns: command invocation (as a list of strings) for
                dmenu -l <num_lines> -p <prompt> -i ...

    """
    dmenu_command = "dmenu"
    conf = configparser.ConfigParser()
    conf.read(expanduser(CONF))
    if not conf.has_section('dmenu'):
        dmenu = [dmenu_command, "-i", "-l", str(num_lines), "-p", str(prompt)]
    else:
        args = conf.items('dmenu')
        args_dict = dict(args)
        dmenu_args = []
        if "dmenu_command" in args_dict:
            command = shlex.split(args_dict["dmenu_command"])
            dmenu_command = command[0]
            dmenu_args = command[1:]
            del args_dict["dmenu_command"]
        if "rofi" in dmenu_command:
            lines = "-i -dmenu -lines"
            # rofi doesn't support 0 length line, it requires at least -lines=1
            # see https://github.com/DaveDavenport/rofi/issues/252
            num_lines = num_lines or 1
        else:
            lines = "-i -l"
        if "l" in args_dict:
            # rofi doesn't support 0 length line, it requires at least -lines=1
            # see https://github.com/DaveDavenport/rofi/issues/252
            if "rofi" in dmenu_command:
                args_dict['l'] = min(num_lines, int(args_dict['l'])) or 1
            lines = "{} {}".format(lines, args_dict['l'])
            del args_dict['l']
        else:
            lines = "{} {}".format(lines, num_lines)
        if "pinentry" in args_dict:
            del args_dict["pinentry"]
    if prompt == "Passphrase":
        if conf.has_section('dmenu_passphrase'):
            args = conf.items('dmenu_passphrase')
            args_dict.update(args)
        rofi_obscure = True
        if conf.has_option('dmenu_passphrase', 'rofi_obscure'):
            rofi_obscure = conf.getboolean('dmenu_passphrase', 'rofi_obscure')
            del args_dict["rofi_obscure"]
        if rofi_obscure is True and "rofi" in dmenu_command:
            dmenu_args.extend(["-password"])
    extras = (["-" + str(k), str(v)] for (k, v) in args_dict.items())
    dmenu = [dmenu_command, "-p", str(prompt)]
    dmenu.extend(dmenu_args)
    dmenu += list(itertools.chain.from_iterable(extras))
    dmenu[1:1] = lines.split()
    dmenu = list(filter(None, dmenu))  # Remove empty list elements
    return dmenu


def get_databases():
    """Parse config.ini and return all available databases

    Returns: [(database name, keyfile, passphrase), (database2, kf, pw), ...]
    """
    conf = configparser.ConfigParser()
    conf.read(expanduser(CONF))
    if not conf.has_section('database'):
        print("No databases defined in {}".format(CONF))
        sys.exit()
    args = conf.items('database')
    args_dict = dict(args)
    dbs = []
    idx = 1
    while True:
        try:
            dbn = expanduser(args_dict['database_{}'.format(idx)])
        except KeyError:
            break
        try:
            keyfile = expanduser(args_dict['keyfile_{}'.format(idx)])
        except KeyError:
            keyfile = ''
        try:
            passw = args_dict['password_{}'.format(idx)]
        except KeyError:
            passw = ''
        dbs.append((dbn, keyfile, passw))
        idx += 1
    return dbs


def open_database(dbo):
    """Open keepass database and return the PyKeePass object

        Args: dbo: tuple (db path, keyfile path, password)
        Returns: PyKeePass object

    """
    dbf, keyfile, password = dbo
    if not password:
        password = get_passphrase()
    try:
        kpo = PyKeePass(dbf, password, keyfile=keyfile)
    except FileNotFoundError:
        Popen(dmenu_cmd(1, "Database does not exist"), stdin=PIPE, stdout=PIPE,
              env=ENV).communicate(input='')
        sys.exit()
    except OSError:
        Popen(dmenu_cmd(1, "Invalid Password or keyfile"), stdin=PIPE,
              stdout=PIPE, env=ENV).communicate(input='')
        sys.exit()
    return kpo


def get_passphrase():
    """Get a password

    Returns: string

    """

    conf = configparser.ConfigParser()
    conf.read(expanduser(CONF))
    pinentry = None
    if conf.has_option("dmenu", "pinentry"):
        pinentry = conf.get("dmenu", "pinentry")
    if pinentry:
        pin = ""
        out = Popen(pinentry,
                    stdout=PIPE,
                    stdin=PIPE).communicate( \
                            input=b'setdesc Get database password\ngetpin\n')[0]
        if out:
            res = out.decode(ENC).split("\n")[2]
            if res.startswith("D "):
                pin = res.split("D ")[1]
        return pin
    else:
        return Popen(dmenu_cmd(0, "Passphrase"),
                     stdin=PIPE,
                     stdout=PIPE).communicate()[0].decode(ENC).rstrip('\n')


def type_entry(entry):
    """Use PyUserInput to type the selected entry

    """
    kbd = PyKeyboard()
    if entry.username:
        kbd.type_string(entry.username)
        if entry.password:
            kbd.tap_key(kbd.tab_key)
    if entry.password:
        kbd.type_string(entry.password)
    # Not sure why we need n=2, but only seems to work that way
    kbd.tap_key(kbd.enter_key, n=2)


def run():
    """Main script entrypoint"""
    databases = get_databases()
    if len(databases) == 1:
        keepass = open_database(databases[0])
    else:
        inp_bytes = "\n".join(i[0] for i in databases).encode(ENC)
        sel = Popen(dmenu_cmd(len(databases)), stdin=PIPE, stdout=PIPE,
                    env=ENV).communicate(input=inp_bytes)[0].decode(ENC)
        if not sel.rstrip():
            sys.exit()
        keepass = open_database([i for i in databases if i[0] == sel.strip()][0])
    entries = keepass.entries
    num_align = len(str(len(entries)))
    entry_pattern = "{:>{na}} - {} - {} - {}"  # Path,username,url
    # Have to number each entry to capture duplicates correctly
    entries_b = "\n".join([entry_pattern.format(j, i.path, i.username, i.url, na=num_align)
                           for j, i in enumerate(entries)]).encode(ENC)
    sel = Popen(dmenu_cmd(min(24, len(entries))), stdin=PIPE, stdout=PIPE,
                env=ENV).communicate(input=entries_b)[0].decode(ENC)
    if not sel.rstrip():
        sys.exit()
    entry = entries[int(sel.split('-', 1)[0])]
    type_entry(entry)


if __name__ == '__main__':
    run()

# vim: set et ts=4 sw=4 :
